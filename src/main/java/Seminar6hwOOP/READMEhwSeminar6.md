## Домашнее задание
Взять реализованный код в рамках семинара 4 и продемонстрировать применение принципов, усвоенных на семинаре.
Нужно в проекте прокомментировать участки кода, которые рефакторим, какой принцип применяем и почему.

Формат сдачи: ссылка на гитхаб проект

## Комментарий к домашнему заданию

За основу был взят код, включающий в себя выполненные задания на семинаре и
домашнее задание к данному семинару
https://github.com/TimofeevDmitrii/HomeWorksJavaOOP/tree/main/src/main/java/Seminar4hwOOP

Проект был структурирован по пакетам Data, Service, View, Controller для большего
удобства восприятия и законченности структуры.

### Simple responsibility

* На семинаре 4 первым явным примером принципа единственной ответственности,
  является создание класса User. Это заложило основу для дальнейшего построения понятной, разбитой по блокам
  системы из наследников класса User. Данный класс взял на себя хранение ФИО пользователя,
  т.е. общих параметров для всех возможных пользователей системы. Потенциально в класс User можно занести
  много других общих полей, таких как день рождения, паспортные данные (для паспортных данных можно создать отдельную сущность) и т.д.
  Это избавило нас от дальнейшего повторения однотипных полей при создании классов конкретных юзеров.

* Далее мы также следовали данному принципу, создавая классы Student, Teacher, StudentService,
  StudentGroup, StudentGroupIterator, StudentGroupService, последовательно наделяя данные классы
  соответствующим функционалом, за который каждый из них будет отвечать. Например, класс Student наследует класс User,
  при этом включает новые поля, необходимые для студента - его id и номер группы; класс Teacher также наследует класс User,
  он содержит новое поле - id учителя. В сложившейся системе, учет id будет вестись внутри каждой категории 
  пользователей (наследниками класса User). Поэтому каждый наследник класса User будет содержать в себе поле для id.
  StudentGroup - сущность, отвечающая за хранение группы студентов: список студентов, 
  номер группы, закрепленный преподаватель.
  
* Аналогично StudentService отвечает за операции с объектами класса Student и его наследников, а TeacherService за работу с объектами 
  класса Teacher и т.д. А классы *View будут отвечать за вывод данных в консоль. 

### Open-Closed

* Прежде всего стоит отметить, что, вероятно, относительно данного принципа невозможно
  полностью, на 100%, "закрыть" любую программу. Это обусловлено тем, что очень трудно 
  предусмотреть при построении архитектуры приложения абсолютно все возможные ситуации, требующие
  внесения некоторых изменений в логику работы приложения; и соответственно, невозможно построить приложение так,
  чтобы абсолютно во всех таких ситуациях при этом не возникло необходимости полностью его переписывать.
  

* Реализуем пример Open-Closed принципа. Возникла потребность создать подтипы студентов в зависимости от формы обучения.
  Создадим для примера наследников класса Student - FullTimeStudent и PartTimeStudent.
  Первый - это студент очного обучения; второй - это студент вечернего обучения. В классе Student
  переопределен метод toString для осуществления вывода студента в консоль в нужной форме, а также имеется
  метод isStudyDay(), принимающий на вход объект типа LocalDate и показывающий,
  каким является этот день для студента. Новые классы-наследники переопределяют эти методы по своему
  и при подстановке их на те места в программе, где может использоваться класс-родитель Student,
  программа не "ломается", в том числе не нарушается и логика работы, и формат вывода. Более того, нам не пришлось
  лесть в код Класса Student или в какой-либо другой класс и что-то там править.
  

* Для демонстрации написаны два варианта кода в Main. В первом варианте с использованием контроллера
  создаются студенты и преподаватели, формируется группа студентов; далее для каждого студента из этой группы
  проверяется выполнение метода isStudyDay из контроллера. 
  Во втором варианте алгоритм тот же; изменения состоят в том, что используется вторая версия контроллера(ControllerV2 наследует Controller),
  из которого вызываются методы по созданию объектов новых классов-наследников FullTimeStudent и PartTimeStudent, а также
  для демонстрации последующих принципов SOLID применяются другие версии idCounterV2, studentView2, teacherView2. 
  При создании ControllerV2 был создан и использован в конструкторе StudentServiceV2(наследник StudentService). В нем добавлены методы
  createFullTimeStudent и createPartTimeStudent. 
  
### Liskov Substitution

* Данный принцип зачастую переплетается с предыдущим принципом - Open/Closed. Это показано на примере 
  создания наследников класса Student - FullTimeStudent и PartTimeStudent - и последующем практическом кейсе в Main.
  Как уже было сказано ранее, новые классы-наследники переопределяют методы toString и isStudyDay по-своему
  и при подстановке их на те места в программе, где может использоваться класс-родитель Student,
  программа не "ломается", в том числе не нарушается и логика работы, и формат вывода; иными словами, не нарушается *принцип 
  наименьшего сюрприза*.
  
### Interface segregation

* Для примера применения данного принципа были создана два интерфейса - StudentBehaviour
  и TeacherBehaviour. Каждый из них будет содержать определенный перечень 
  методов, которые характерны именно для студента и для учителя соответственно. Например,
  методы isStudyDay и isWorkDay по своей логике работы похожи, но результат разный: один
  должен распознавать дни как учебные или неучебные для студента, а другой - распознавать дни 
  как рабочие или нерабочие для учителя. 
  Аналогично методы по реализации функции участия в экзаменах в данных интерфейсах:
  студент может только сдать или не сдать экзамен (метод passExam), а учитель, принимая
  у какого-то студента экзамен, может "сказать", что экзамен сдан или не сдан данным студентом (метод checkExam).
  Данные методы разные по своей сути и выходным результатам, поэтому будет неправильно каждый из них
  реализовывать и в Teacher, и в Student; поэтому они вынесены в разные интерфейсы.
  Еще одни пример, может быть и тривиальный, тем не менее он подходит. Для студента мы можем
  добавить метод willGoStudy, показывающий пойдет ли студент учиться или "забьет на пары"; для
  учителя такое поведение в принципе невозможно. 
  
* Также думаю, что сюда можно отнести использование дополнительных интерфейсов UserService, UserView.
  Мы не стали их реализовывать в классах User и его наследниках, поручив это классам, отвечающим
  за работу с ними (сервисы) и за определенный вывод пользователей (вью).
  

