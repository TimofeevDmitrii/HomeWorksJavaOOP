## Домашнее задание
Взять реализованный код в рамках семинара 4 и продемонстрировать применение принципов, усвоенных на семинаре.
Нужно в проекте прокомментировать участки кода, которые рефакторим, какой принцип применяем и почему.

Формат сдачи: ссылка на гитхаб проект

## Комментарий к домашнему заданию

За основу был взят код, включающий в себя выполненные задания на семинаре и
домашнее задание к данному семинару
https://github.com/TimofeevDmitrii/HomeWorksJavaOOP/tree/main/src/main/java/Seminar4hwOOP

Проект был структурирован по пакетам Data, Service, View, Controller для большего
удобства восприятия и законченности структуры.

### Simple responsibility

* На семинаре 4 первым явным примером принципа единственной ответственности,
  является создание класса User. Это заложило основу для дальнейшего построения понятной, разбитой по блокам
  системы из наследников класса User. Данный класс взял на себя хранение ФИО пользователя,
  т.е. общих параметров для всех возможных пользователей системы. Потенциально в класс User можно занести
  много других общих полей, таких как день рождения, паспортные данные (для паспортных данных можно создать отдельную сущность) и т.д.
  Это избавило нас от дальнейшего повторения однотипных полей при создании классов конкретных юзеров.

* Далее мы также следовали данному принципу, создавая классы Student, Teacher, StudentService,
  StudentGroup, StudentGroupIterator, StudentGroupService, последовательно наделяя данные классы
  соответствующим функционалом, за который каждый из них будет отвечать. Например, класс Student наследует класс User,
  при этом включает новые поля, необходимые для студента - его id и номер группы; класс Teacher также наследует класс User,
  он содержит новое поле - id учителя. В сложившейся системе, учет id будет вестись для каждой категории 
  пользователей (наследников класса User) независимо от других категорий. Поэтому каждый наследник класса User будет содержать в себе поле для id.
  StudentGroup - сущность, отвечающая за хранение группы студентов: список студентов, 
  номер группы, закрепленный преподаватель.
  
* Аналогично StudentService отвечает за операции с объектами класса Student и его наследников, а TeacherService за работу с объектами 
  класса Teacher и т.д. А классы *View будут отвечать за вывод данных в консоль. 

### Open-Closed

* Прежде всего стоит отметить, что, вероятно, относительно данного принципа невозможно
  полностью, на 100%, "закрыть" любую программу. Это обусловлено тем, что очень трудно 
  предусмотреть при построении архитектуры приложения абсолютно все возможные ситуации, требующие
  внесения некоторых изменений в логику работы приложения; и соответственно, невозможно построить приложение так,
  чтобы абсолютно во всех таких ситуациях при этом не возникло необходимости полностью его переписывать.
  

* Реализуем пример Open-Closed принципа. Возникла потребность создать подтипы студентов в зависимости от формы обучения.
  Создадим для примера наследников класса Student - FullTimeStudent и PartTimeStudent.
  Первый - это студент очного обучения; второй - это студент вечернего обучения. В классе Student
  переопределен метод toString для осуществления вывода студента в консоль в нужной форме, а также имеется
  метод isStudyDay(), принимающий на вход объект типа LocalDate и показывающий,
  каким является этот день для студента. Новые классы-наследники переопределяют эти методы по своему
  и при подстановке их на те места в программе, где может использоваться класс-родитель Student,
  программа не "ломается", в том числе не нарушается и логика работы, и формат вывода. Более того, нам не пришлось
  лесть в код Класса Student или в какой-либо другой класс и что-то там править.
  

* Для демонстрации написаны два варианта кода в Main. В первом варианте с использованием контроллера
  создаются студенты и преподаватели, формируется группа студентов; далее для каждого студента из этой группы
  проверяется выполнение метода isStudyDay из контроллера. 
  Во втором варианте алгоритм тот же; изменения состоят в том, что используется вторая версия контроллера(ControllerV2 наследует Controller),
  из которого вызываются методы по созданию объектов новых классов-наследников FullTimeStudent и PartTimeStudent, а также
  для демонстрации последующих принципов SOLID применяются другие версии idCounterV2, studentView2, teacherView2. 
  При создании ControllerV2 был создан и использован в конструкторе StudentServiceV2(наследник StudentService). В нем добавлены методы
  createFullTimeStudent и createPartTimeStudent. 
  
### Liskov Substitution

* Данный принцип зачастую переплетается с предыдущим принципом - Open/Closed. Это показано на примере 
  создания наследников класса Student - FullTimeStudent и PartTimeStudent - и последующем практическом кейсе в Main.
  Как уже было сказано ранее, новые классы-наследники переопределяют методы toString и isStudyDay по-своему
  и при подстановке их на те места в программе, где может использоваться класс-родитель Student,
  программа не "ломается", в том числе не нарушается и логика работы, и формат вывода; иными словами, не нарушается *принцип 
  наименьшего сюрприза*.
  
### Interface segregation

* Для примера применения данного принципа были создана два интерфейса - StudentBehaviour
  и TeacherBehaviour. Каждый из них будет содержать определенный перечень 
  методов, которые характерны именно для студента и для учителя соответственно. Например,
  методы isStudyDay и isWorkDay по своей логике работы похожи, но результат разный: один
  должен распознавать дни как учебные или неучебные для студента, а другой - распознавать дни 
  как рабочие или нерабочие для учителя. 
  Аналогично методы по реализации функции участия в экзаменах в данных интерфейсах:
  студент может только сдать или не сдать экзамен (метод passExam), а учитель, принимая
  у какого-то студента экзамен, может "сказать", что экзамен сдан или не сдан данным студентом (метод checkExam).
  Данные методы разные по своей сути и выходным результатам, поэтому будет неправильно каждый из них
  реализовывать и в Teacher, и в Student; поэтому они вынесены в разные интерфейсы.
  Еще одни пример, может быть и тривиальный, тем не менее он подходит. Для студента мы можем
  добавить метод willGoStudy, показывающий пойдет ли студент учиться или "забьет на пары"; для
  учителя такое поведение в принципе невозможно. 
  
* Также думаю, что сюда можно отнести использование дополнительных интерфейсов UserService, UserView.
  Мы не стали их реализовывать в классах User и его наследниках, поручив это классам, отвечающим
  за работу с ними (сервисы) и за определенный вывод пользователей (вью).
  
### Dependency Inversion

* На семинаре 5 мы создали метод по расчету следующего id для определенного типа пользователя (см. семинар 5). В данном проекте
  принят такой же принцип формирования id - он будет рассчитываться для каждой определенной категории пользователей независимо.
  Для этого на семинаре 5 был сделан один общий метод для расчета id (getFreeId), на вход которого подается тип пользователя (константа из файла enum).
  Минус такой реализации в том, что это может привести к проблеме, связанной с принципом Dependency Inversion.
  Вызов метода происходит в dataService при вызове метода create. Проблема может быть в том, что реализация такого метода нас
  может не устраивать и тогда нам нужно будет лезть в первоначальный код и править метод getFreeId. Более того, его может и не быть вовсе
  в какой-то из модификаций дата-сервис при использовании его в контроллере, так как "обязанности" по реализации расчета и формирования id в коде
  не прописано.
  
  В семинаре 4 расчет id и формирование идет другим путем. В классе Student и Teacher имеются статические переменные,
  используя которые через конструктор при создании объектов данного класса происходит присвоения нового id.
  У такого метода есть свои проблемы. Которые тоже можно будет решить, только правя первоначальный код.
  
* Как уже говорилось ранее, была принята концепция для расчета id из семинара 5. Но для реализации был создан интерфейс
  CountNextId и в нем прописан метод getFreeId(type). В классе контроллер будет использоваться объект класса IdCounter, который будет обязательно реализовывать
  данный интерфейс. В результате мы уже не зависим от какого-то конкретного класса и можем использовать любой 
  класс, содержащий в себе метод по расчету следующего id.
  
* Таким же образом поступим, используя интерфейс UserView: создадим классы StudentView и TeacherView, реализующий
  UserView.
  
* Будем принимать в конструкторе класса Controller три объекта следующих типов:
  CountNextId nextIdCounter, UserView<Student> studentView, UserView<Teacher> teacherView.
  Для демонстрации результатов было написано 2 варианта кода в Main, в первом и втором для демонстрации
  используются разные версии объектов указанных классов.
  
* Также указывая при объявлении переменных нужные параметры в виде реализуемых интерфейсов с соответствующими
  обобщениями(в классе Controller):

  protected UserService<Student> studentService = new StudentService();
  protected UserService<Teacher> teacherService = new TeacherService();
  
  мы добьемся того, что в данных переменных будут использоваться объекты такого типа, что они должны будут
  обязательно реализовывать данные интерфейсы; если данное условие не будет выполняться, то мы будем получать ошибки
  на этапе компиляции, что гораздо лучше, чем получить ошибку во время работы. Получение данных объектов в Controller также
  можно также построить через конструктор.
  
PS. Классы TeacherCollective и TeacherCollectiveService не стал затрагивать при рефакторинге, т.к.
 проект получается достаточно объемным, поэтому лишь поместил их в нужные папки 
  
